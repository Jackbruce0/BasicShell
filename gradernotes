I wrote this code myself, but gained some inspiration from several sources.

Sources: - I learned a lot of the mechanics for verical piping from this
           example
           + www.cs.usfca.edu/~sjengle/ucdavis/ecs150-w04/source/pipe.c
         - getword method was adapted from Foster's getchar example in inout2.c
           found in ~masc0000/CbyDiscovery/ch2/inout2.c
         - syntax and usage of execvp commmand was learned from exec1.c found
           in ~cs570/exec1.c
         - syntax and usage of fork command was learned from fork1.c found in 
           ~cs570/fork1.c
         - syntax and usage of getpid was learned from fork2.c found in
           ~cs570/fork2.c
         - loop for reaping child processes was adapted from lines 97-102 of
           pipe.c found in ~cs570/pipe.c
         - syntax and usage of dup2 was learned from dup2.c found in
           ~cs570/dup2.c
         - use of signals and a signal handler was learned from sig.c and 
           sighandler.c found in ~cs570/sig.c and ~cs570/sighandler.c
         - template for main method and parse was also followed from program 2
           instructions
         - http://www.tldp.org/LDP/abs/html/exitcodes.html for reserved exit 
           codes
         - https://www.geeksforgeeks.org/error-handling-c-programs/ for
           learning how to use 'errno' variable
         - man pages for dup2, execvp, getenv, chdir, exit, fork, open, perror,
           wait, stat, fflush, access, sigaction, signal, setpgid, getpgrp,
           and killpg

Design Decisions:
         - 'echo hi > a >> b' will fail as a command cannot write to 2 
           different places at once
         - If a a set of 2 piped commands is backgrounded. name and PID of
           left hand command will be reported
           + ex) `ls | cat &` will report "ls [PID]"
         - I used 'strdup' in the implementation of my history feature. 
            + You gave me permission to use this method via email as I only use 
              it to overwrite char pointers that I assigned to NULL. 
         - `[command] [>|<|>&|>>|>>&] &` will write/read to/from a file named
           '&' if it meets standards for a valid file
            + as opposed to putting the command in the background with a 
              redirect pointing to an empty file
         - For history (`!!`, `![0-9]`, and `!$`) I used an array of structs 
           that save the state of p2 during the time that a previous command
           was executed.
            + When previous command is requested we simply load in respective
              index of history array
         - handled error exit codes with errno variable
         - now that we must handle pipelines, I increased newargv's size to
           2*MAXARGS (40). As new projected maximum is theoretically double
           what I expected for a single command
Known Deficiencies:
         - If second argument of pipe is empty, no error is detected
            + ex) `sort | &` will simply run 'sort' in the background (as if
                  the pipe was not even there
         - when a background process has printed output, it will print after the
           parent issued the prompt and the parent will not issue another
           prompt on a seperate line like tcsh does
            + performance is not hindered, shell is still activitely waiting
              for input
